/*!
 * \Lampyris GameEngine C++ Source File
 * \Module:  Serialization
 * \File:    le_data_stream.cpp
 * \Author:  BookRed
 * \Email:   390031942@qq,com
*/

// LE Includes
#include "le_data_stream.h"
#include "../Base/le_class_info.h"

const std::string LEDataStream::ms_header[2] =
{ "This json file is auto-generated by Lampyris Engine\n",
  "ATTENTION!!! Any manually change may make the program crash\n" };

void LEDataStream::archive(LEObject* &rootObject, int vectorElementIndex, int byteCount) {
	if (this->m_archivePhase == AP_WRITE) {
		bool contains = this->m_collectedObjects.contains(rootObject);
		unsigned int uuid = 0;
		if (rootObject != nullptr) {
			uuid = rootObject->getInstanceID();
			int index = this->m_collectedObjects.size();
			auto classInfo = rootObject->getClassInfo();

			// update objects set
			this->m_collectedObjects.insert(std::make_pair(rootObject, uuid));

			// write basic information of 'LEObject'
			this->m_writer->writeAt(uuid, "objects", index, "uuid");
			this->m_writer->writeAt(classInfo->getClassName(), "objects", index, "class");

			this->m_objectIndexStack.push(index);
			auto properties = classInfo->getAllProperties();
			for (auto& property : properties) {
				if (property->getPropertyFlag() & LEProperty::PF_SAVE_LOAD) {
					this->pushCurrentPropertyName(property->getPropertyName());
					property->archive(*this, rootObject);
					this->popCurrentPropertyName();
				}
			}
			this->m_objectIndexStack.pop();
		}
		if (!this->m_objectIndexStack.empty()) {
			if (vectorElementIndex == -1) {
				this->m_writer->writeAt(uuid, "objects",
					                          this->m_objectIndexStack.top(),
					                          this->m_currentPropertyNameStack.top());
			}
			else {
				this->m_writer->writeAtCurrent(uuid, vectorElementIndex);
			}
		}
	}
	else {
		// get the uuid of the related LEObject
		unsigned int uuid = -1;
		if (vectorElementIndex == -1) {
			uuid = this->m_reader->readUInt("objects",
				                            this->m_objectIndexStack.top(),
				                            this->m_currentPropertyNameStack.top());
		}
		else {
			uuid = this->m_reader->readUIntAtCurrent(vectorElementIndex);
		}
		// try to get the object in the map by uuid
		// if exists, we just assign it without hesitation
		// else, we save the address of the pointer and uuid to the vector 'm_unassignedObjectInfo', and assign later 
		if (this->m_objectMap.contains(uuid)) {
			this->assignLEObject(&rootObject,uuid, byteCount);
		}
		else {
			// If byteCount is equal to 0, the archived type is LEObject*, otherwise it is LEObject 
			if (!byteCount) { 
				rootObject = nullptr;
			}
			this->m_unassignedObjectInfo.push_back(UnassignedObjectInfo{&rootObject,uuid,byteCount});
		}
	}
}

void LEDataStream::setArchiveFilePath(const std::string& path) {
	this->m_archivePath = path;
}

void LEDataStream::setArchivePhase(ArchivePhase phase) {
	this->m_archivePhase = phase;
}

void LEDataStream::pushCurrentPropertyName(const std::string& name) {
	this->m_currentPropertyNameStack.push(name);
}

void LEDataStream::saveObject(LEObject* object) {
	this->m_archivePhase = AP_WRITE;
	this->m_writer = LEJsonWriter::open(this->m_archivePath);
	this->archive(object);
	this->m_writer->writeAt(this->m_collectedObjects.size(), "object_count");
	this->m_writer->writeAt("1.0.0", "version");
	this->m_writer->writeAt(object->getInstanceID(), "root");
	this->m_writer->writeComment(this->ms_header[0]);
	this->m_writer->writeComment(this->ms_header[1]);
	this->m_writer->saveToFile();
}

LEObject* LEDataStream::loadObject() {
	this->m_archivePhase  = AP_READ;
	this->m_reader        = LEJsonReader::open(this->m_archivePath);
	int objectCount       = this->m_reader->readInt("object_count");
	std::string version   = this->m_reader->readString("version");
	unsigned int rootUUID = this->m_reader->readUInt("root");
	this->m_unassignedObjectPointers.reserve(4096);
	for (int i = 0; i < objectCount; i++) {
		this->m_objectIndexStack.push(i);
		const std::string& className = this->m_reader->readString("objects", i, "class");
		const int uuid               = this->m_reader->readUInt("objects", i, "uuid");
		LEObject* object             = LEReflectionSystem::getInstance()->createInstance(className);
		this->m_objectMap[uuid]      = object;
		const LEClassInfo* classInfo = object->getClassInfo();
		auto properties              = classInfo->getAllProperties();
		for (auto& property : properties) {
			this->pushCurrentPropertyName(property->getPropertyName());
			property->archive(*this, object);
			this->popCurrentPropertyName();
		}
		this->m_objectMap[uuid] = object;
		this->m_objectIndexStack.pop();
	}
	// assign the unassigned objects in m_unassignedObjectInfo
	for (auto& info : this->m_unassignedObjectInfo) {
		this->assignLEObject(info.ppObject, info.uuid, info.objectByteCount);
	}
	this->m_unassignedObjectInfo.clear();
	this->m_unassignedObjectPointers.clear();
	return this->m_objectMap[rootUUID];
}